---
layout: default
title: Exercises and Lab
nav_order: 3
parent: Day 1
permalink: /docs/day1/exercises.html
---

This exercise and lab will get you familiar with the basics of the terraform CLI and configuration language.

**In your terminal, navigate to `/exercises/intro/`**

## Creating resources with Terraform

All of your configuration files need to end with the file extension `.tf` and be in the same directory.

<input type="checkbox" class="task-list-item-checkbox">Start by creating a new file in the `/exercises/intro/` directory called `main.tf`. 

> If there are very few resources to create, it's common to see just one `main.tf` file. When the app gets complex, however, it's best practice to split the resources into separate files by service type. For example: `s3.tf` `iam.tf` `vpc.tf`.

In this terraform file, we'll add our first resource: an S3 bucket. If you need help with the syntax, check out the terraform [`aws_s3_bucket` docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket). Notice the docs say that only one argument is required for the S3 bucket resource. To keep it simple, that's all we will specify.

**Remember that S3 bucket names need to be globally unique**. You can put your name or some random digits in the name to make sure it's unique.

<input type="checkbox" class="task-list-item-checkbox">Add a `aws_s3_bucket` resource with a unique `bucket` name.

<details><summary>Not sure how?</summary>
<br>
In <code>main.tf</code>:
<pre>
resource "aws_s3_bucket" "RESOURCE_NAME" {
    bucket = "BUCKET_NAME"
}
</pre>
</details>

Now we need to run the terraform CLI. You can try to run `terraform plan` immediately, but we did not initialize yet so it will error.

<input type="checkbox" class="task-list-item-checkbox">Run `terraform init`

Notice at the top of the output it is downloading and installing a provider called "hashicorp/aws". Terraform inferred from our `main.tf` that it needed the AWS provider package. It also created some other files in your directory, which terraform will use during deployments later.

When we run `terraform plan` now, terraform prompts that we need to give a value for `provider.aws.region`. That's the AWS provider, it needs to know the region in which to deploy resources.

<input type="checkbox" class="task-list-item-checkbox">Run `terraform plan` and tell it to deploy to `us-east-1`

Terraform throws an error saying that it can't find credentials. That's because, unless otherwise specified, it is going to look for your default AWS credentials. That could be the `default` shared credentials profile or the `AWS_ACCESS_KEY_ID` (+ others) environment variables. We _could_ set the default credentials, but we'd much rather use our named profiles to authenticate.

To do this, we specify an AWS `provider` block in our file and give it a `profile` argument. We can also give it a `region` to prevent the CLI from asking us every time. See the [provider docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs) for help with syntax. The block can go anywhere, but generally you'll see them specified in a file called `_providers.tf`. The underscore denotes that it doesn't create resources and is more like a helper file.

<input type="checkbox" class="task-list-item-checkbox">Add an AWS `provider` block to a new file called `_providers.tf` file and tell it use your `saml` profile generated by aws-fed. Also tell it to use the us-east-1 region. If you haven't already, now is a good time to login to the sandbox account with aws-fed

<details><summary>Not sure how?</summary>
<pre>
provider "aws" {
    profile = "saml"
    region  = "us-east-1"
}
</pre>
</details>

Now when we run another plan, it doesn't ask for a region, and it successfully prints out the plan.

<input type="checkbox" class="task-list-item-checkbox">Run `terraform plan` again

Take a look at the plan it outputs. The green `+` means that those resources or arguments will be _created_ since they don't exist yet. There are several arguments that we didn't specify. Those are not required, and terraform will just use the default value. Several of the arguments say "(known after apply)", meaning terraform will not know those values until it actually creates them (because they are returned by the AWS API).

<input type="checkbox" class="task-list-item-checkbox">If you're satisfied with the plan, run `terraform apply`

Go take a look at the S3 AWS console in your sandbox account. Your bucket should be there!

## Lab

Let's introduce some changes and see how terraform handles those.

<input type="checkbox" class="task-list-item-checkbox">Add a `versioning` _block_ (**not _argument_!!**) to the S3 bucket and deploy it - [docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#versioning)

If able, terraform will update the resource in place instead of deleting and recreating the bucket. Sometimes, this is not possible due to limitations within AWS. For example, you cannot rename an S3 bucket, so that would force terraform to destroy it and then recreate it.

You should have noticed some differences with the plan this time. Anything with a `~` in front means it will be updated in place (terraform does not need to destroy it).

Now, let's replace the `bucket` argument with a [`bucket_prefix`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#bucket_prefix) argument. This adds a date to the end of your bucket name, which makes sure it unique.

<input type="checkbox" class="task-list-item-checkbox">Switch `bucket` to `bucket_prefix` and deploy

As mentioned, terraform needs to delete the S3 bucket because we renamed it, which AWS does not allow.

> Do you foresee any problems with this? Luckily, AWS wouldn't let you delete a bucket if it wasn't empty anyway, but this highlights the importance of checking your plan before applying. We only changed one argument. There are AWS resources that will force recreation for things much less obvious than a name.

<details><summary>Solution</summary>
Add versioning:
<pre>
resource "aws_s3_bucket" "my_bucket" {
    ...
    versioning {
        enabled = true
    }
}
</pre>
<code>terraform plan</code><br>
<code>terraform apply</code>
<hr>
Switch to <code>bucket_prefix</code>:
<pre>
resource "aws_s3_bucket" "my_bucket" {
    bucket_prefix = "BUCKET_NAME-"
    ...
}
</pre>
<code>terraform plan</code><br>
<code>terraform apply</code><br>
<b>!! It will delete and recreate your bucket with a new name !! </b>

</details>

### Bonus

All of these terraform configuration files (and eventually state) are going to live somewhere in version control, maintained by several people. Terraform requires the resources are updated with the same or greater version of terraform used to create them. As in, if you create resources on 0.14, everybody else that updates those resources must use version >= 0.14.

Similarly, although not necessarily required, everybody should be using the same provider version as well. Or at a minimum, the same major version.

We can add some more _blocks_ to our terraform configuration to specify a version constraint for terraform and the providers. If anyone runs terraform outside these constraints, terraform will error. Like the `provider` itself, these blocks should go in the `_providers.tf` file.

Here are some hints:
- the version constraint: `~> 3.0` means any version `3.X.X`
- the version constraint: `>= 0.15.5` means anything above, including `0.16`

[Terraform version constraints](https://www.terraform.io/docs/language/settings/index.html#specifying-a-required-terraform-version)<br>
[Terraform provider version constraints](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)

Change the terraform version to 0.14 and see what happens. Now change it to 0.16.

Play around with the provider versions as well.

<details><summary>Solution</summary>
<br>
Create a new file called <code>_providers.tf</code>:
<br>
<pre>
terraform {
  required_version = ">= 0.15.5"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.62"
    }
  }
}
</pre>
</details>

## Cleanup

`terraform destroy`